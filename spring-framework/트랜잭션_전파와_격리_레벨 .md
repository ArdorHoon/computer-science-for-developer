# 트랜잭션 전파와 격리 레벨 

* 트랜잭션(Transaction) : 단일 작업 단위로 실행되는 하나 이상의 데이터베이스 작업 시퀀스
* 트랜잭션 ACID
  * 원자성(Atiomicity) : 트랜잭션은 분할할 수 없는 단일 작업 단위로 취급
  * 일관선(Consistency) : 트랜잭션은 트랜잭션 전후에 데이터베이스 일관성 유지
  * 격리성(isolation) : 트랜잭션은 서로 간섭할 수 없도록 서로 격리되어야 함
  * 영속성(Durability) : 트랜잭션은 커밋되면 데이터베이스에 대한 변경 내용이 영구적으로 유지하며 후속 장애에도 영향을 받지 않아야 함


## Spring에서 트랜잭션 처리 방법


## Spring이 지원하는 트랜잭션 전파 유형

우리는 Spring이 트랜잭션을 어떻게 진행시킬지 결정하도록 전파 속성을 전달해야 한다. 

1. Requried
2. Supports


</br>


## Spring에서 제공하는 트랜잭션 격리 수준

격리 수준은 <mark>**동시에 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정**</mark>, Spring은 아래 5가지 격리수준 속성을 지원

* DEFAULT (데이터 액세스 기술 또는 DB 드라이브의 디폴트 설정에 따름)
* READ_UNCOMMITED
* READ_COMMITED
* REPEATABLE_READ
* SERIALIZABLE

이에 대해서 [정리한 글](https://github.com/ArdorHoon/computer-science-for-developer/blob/main/database/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EA%B2%A9%EB%A6%AC_%EC%88%98%EC%A4%80%20.md)이 있으니 클랙해서 확인해 보자

### Spring에서 격리 수준 사용법

#### Read Uncommitted

```java
@Service
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public class UserService {
  
    @Autowired  
    private UserRepository userRepository;  
  
    public void updateUser(User user) {  
        userRepository.save(user);  
    }  
}

```

</br>

#### Read Committed

```java
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class UserService {
  
    @Autowired  
    private UserRepository userRepository;  
  
    public User getUserById(Long id) {  
        return userRepository.findById(id)  
            .orElseThrow(() -> new EntityNotFoundException("User not found"));  
    }  
}

```

</br>

#### Repeatable Read

```java
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class UserService {
  
    @Autowired  
    private UserRepository userRepository;  
  
    public User getUserById(Long id) {  
        return userRepository.findById(id)  
            .orElseThrow(() -> new EntityNotFoundException("User not found"));  
    }  
}

```

</br>


#### Serializable

```java
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class UserService {
  
    @Autowired  
    private UserRepository userRepository;  
  
    public User getUserById(Long id) {  
        return userRepository.findById(id)  
            .orElseThrow(() -> new EntityNotFoundException("User not found"));  
    }  
}

```

</br>
