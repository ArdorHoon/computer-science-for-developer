# 테스트 프레임워크

Spring 공식 문서에서 Spring은 통합 테스트와 단위 테스트를 지원하고 TDD를 지지한다. 용어를 정리하면 아래와 같다. 

</br>

> <mark>TDD(Test-Driven-Development)</mark> : 테스트 주도 개발로 테스트 케이스를 먼저 작성한 후 실제 코드를 개발하는 절차를 의미한다. </br>
> <mark>통합 테스트(Integration Test)</mark> : 두 개 이상의 단위가 함께 잘 작동하는지 확인하는 테스트 </br>
> <mark>단위 테스트(Unit Test)</mark> : 소프트웨어 개발 과정에서 가장 작은 단위의 코드, 예를 들어 함수나 메서드 등을 대상으로 하는 테스트


보통 단위 테스트를 위해 JUnit을 많이 사용하고 Spring MVC 통합 테스트를 위해 MockMvc를 많이 사용한다.

</br>

## 1️⃣ JUnit


</br>

## 2️⃣ MockMVC

<mark>**Spring 프레임워크에서 제공하는 웹 애플리케이션 테스트용 라이브러리**</mark>

주로 Controller의 동작을 테스트하는데 사용한다. MockMvc를 사용하면 HTTP 요청을 작성하고 컨트롤러의 응답을 검증할 수 있다. 이를 통해 실제 서버에 구현한 Application을 올리지 않고 컨트롤러의 동작 확인이 가능하다.

</br>


### ♦️ GET 방식 사용법

아래와 같은 Controller의 GET 요청을 테스트 해보자고 하자. (@RestController : Spring 4.0에서 추가 기존 @Controller에 @ResponseBody가 추가, JSON 또는 XML 형식으로 HTTP 응답에 담아서 전송)

</br>

```java
@RestController
public class TestController {

    @GetMapping("/test")
    public String testGet(@RequestParam String name, @RequestParam String id){
        return name +": "+ id;
    }
}

```

해당 Controller에 대한 테스트 클래스를 아래와 같이 만들어준다.

```java
@RunWith(SpringRunner.class)
@WebMvcTest(TestController.class)
class TestControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void testGet() throws Exception {

        MultiValueMap<String, String> info = new LinkedMultiValueMap<>();

        info.add("name", "Jake");
        info.add("id", "11250");

        mockMvc.perform(
                MockMvcRequestBuilders.get("/test")
                        .params(info))
                .andExpect(status().isOk())
                .andExpect(content().string("Jake: 11250"))
                .andDo(print());

    }
}

```


 * perform() : 요청을 전송하는 역할, 결과를 <code>ResultActions</code> 객체를 받으며, 해당 객체는 리턴 값을 검증할 수 있는 <code>andExpect()</code> 메소드를 제공 
 * get("url path") : HTTP 메소드 결정할 수 있음(<code>get()</code>, <code>post()</code>, <code>put()</code>, <code>delete()</code>)
 * params() : <키, 값> 파라미터를 전달할 수 있음 (여러 개일 때는 **params()**, 하나일 때는 **param()**을 사용)
 * andExpect() : 응답을 검증하는 역할
   * status() - 상태코드
   * view() - 리턴하는 뷰 이름 검증 (view().name("test")
   * redirect() - 리다이렉트 응답을 검증
   * content() - 응답정보 검증
 * andDo(print()) : 요청/응답 전체 메시지 확인 가능  


실제 해당 결과를 테스트하면 인텔리제이에서 아래와 같이 확인할 수 있다.  (테스트 통과)

![result](https://github.com/user-attachments/assets/34e85a70-337f-494e-b1ae-1f316ef23425)


</br>


### ♦️ POST 방식 사용법

이번에는 POST 방식에서 어떻게 테스트하는가 확인해 보자

```java

//lombok으로 구현한 User 클래스
@Getter
@Setter
@AllArgsConstructor
public class User {
    private String name;
    private String id;
}


//TestController
@RestController
@RequestMapping("/start")
public class TestController {

    @PostMapping("/test")
    public String testGet(@RequestBody User user){
        return user.getName() + ": "+ user.getId();
    }
}

```

해당 POST 메소드를 MockMVC 테스트로 작성하면 아래와 같다.

```java

@RunWith(SpringRunner.class)
@WebMvcTest(TestController.class)
class TestControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void testGet() throws Exception {

        String content = objectMapper.writeValueAsString(new User("Jake", "11020"));

        mockMvc.perform(
                        MockMvcRequestBuilders.post("/start/test")
                                .content(content)
                                .contentType(MediaType.APPLICATION_JSON)
                                .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().string("Jake: 11020"))
                .andDo(print());

    }


}

```

이에 따른 결과를 아래와 같이 나온다. (테스트 통과)


![result2](https://github.com/user-attachments/assets/ca9fdb90-757d-49cb-a322-83bb8759326e)

</br>

