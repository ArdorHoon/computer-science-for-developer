# CPU Scheduling과 알고리즘


## 🔵 CPU Scheduling

<mark>CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업</mark>

Dispather를 통해 CPU를 해당 프로세스에게 넘겨준다. 이 과정이 Context Switch이다. <code> **CPU utilization**(이용률)</code>과 <code>**Throughput** (처리량)</code>을 통해 스케줄링 성능을 평가할 수 있다. CPU 이용률을 최대화하는 것이 다중 프로세서 운영체제 설계의 핵심!

### ▶︎ 그렇다면 왜 CPU는 Scheduling이 필요할까?</br>

컴퓨터 시스템 내의 프로세스의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지며, 극히 일부분만 긴 CPU 버스트를 갖는다. 이는 I/O 작업을 수행하는 프로세스가 상당히 많은 부분을 차지한다는 뜻이다. 즉, 대화형 작업을 많이 수행해야 하는데, 사용자에 대한 빠른 응답을 위해서는 해당 프로세스한테 우선적으로 CPU를 할당해야한다. 이러한 이유로 CPU 스케줄링이 필요해졌다.


<p align="center">
<img src="https://github.com/user-attachments/assets/d23c436c-fce8-490a-b0dc-4f30c7d023e4" width="50%" height="50%"></br>
</p></br>


- CPU burst : 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 단계 
- I/O burst : 커널에 의해 입출력 작업을 진행하는 단계, 운영체제를 통해 서비스가 실행됨

</br>

#### ✴︎ 번외

- CPU bound process : I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스 (계산 위주 프로그램)
- I/O bound process : I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스 (사용자에게 인터렉션을 계속 받는 대화형 프로그램)

</br>

### ▶︎ 4가지 상황에서 Scheduling 발생

1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)
4. 프로세스가 종료할 때

</br>

- **비선점 스케줄링**은 강제로 빼앗지 않고 자진반납하는 방식. (1,4 번)
- **선점 스케줄링**은 강제로 CPU를 회수하는 방식 (2, 3번)

## 🔵 Scheduling 알고리즘

### 1. 선입선출 스케줄링 (FCFS, First-Come First Served)
- 먼저 온 순서대로 처리하는 방식 (비선점)
- CPU를 오래쓰는 프로세스를 할당받으면 나머지는 기다려야 하기때문에 비효율적임



### 2. 최단 작업 우선 스케줄링 (SJF, Shortest-Job-First)
- CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- 평균 대기 시간을 가장 짧게하는 알고리즘
- 비선점형, 선점형 두가지 방식 모두 존재
- Starvation (기아) 문제가 있음
    - 긴 프로세스가 영원히 CPU를 잡지 못할 수 있음
- CPU 버스트 시간을 미리 알 수 없다는 문제점이 있음



### 3. 우선순위 스케줄링 (Priority Scheduling)
- 우선 순위가 제일 높은 프로세스에게 CPU 할당
- 비선점형, 선점형 두 가지 방식 모두 존재
- Starvation (기아) 문제가 있음
    - Aging (노화) 기법으로 해결가능 - 시간이 지나면 우선순위를 높이는 방식
- 무한 봉쇄 문제가 있다.
    - 실행 준비는 되어있으나 cpu를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄된 것으로 간주할 수 있음




### 4. 라운드 로빈 스케줄링 (RR, Round Robin)
- 각 프로세스는 동일한 크기의 할당 시간인 time quantum을 가짐
- 할당 시간이 지나면 프로세스는 CPU를 뺏기고 Ready Queue 맨 뒤에서 줄을 서게 됨
- 짧은 응답 시간 보장
    - n개의 프로세스가 있을 때, 할당 시간이 q인 경우 어떤 프로세스도 (n - 1) * q 이상 기다리지 않음
- 성능
    - time quantum이 커질수록 FCFS에 가까워짐
    - time quantum이 작아질수록 context switch 오버헤드가 증가함
- 모든 시간이 동일한 job만 있을 때는 비효율적이다.

### 5. 멀티레벨 큐 (Multi-Level Queue)
- Ready Queue를 우선순위에 따라 여러개로 분할
    - 빠른 응답을 필요로하는 대화형 작업은 전위 큐에 넣고 주로 라운드로빈을 사용
    - 계산 위주의 작업은 후위 큐에 넣고 주로 FCFS를 사용
- 멀티 레벨 큐 자체에 대한 스케줄링이 필요하다.
    - 고정 우선 순위 방식 (Fixed Priority Scheduling)
        - 전위 큐에 있는 프로세스에게 우선적으로 CPU 할당, 전위 큐가 비어있는 경우에 후위 큐에 있는 프로세스에 CPU 할당
        - Starvation 가능성 존재
    - 타임 슬라이스 방식 (Time Slice)
        - 각 큐에 CPU time을 적절한 비율로 할당


        
### 6. 멀티 레벨 피드백 큐 (Multi-Level Feedback Queue)
- 프로세스가 여러개로 분할된 Ready Queue 내에서 다른 큐로 이동이 가능
- aging 기법으로 구현 가능
    - 우선순위가 낮은 큐에서 오래 기다렸으면 우선순위가 높은 큐로 승격하는 방식
- 현재 사용되는 가장 일반적인 CPU 스케줄링 알고리즘
- 멀티 레벨 피드백 큐의 요소
    - 큐의 수
    - 각 큐의 스케줄링 알고리즘
    - 프로세스를 상위 큐로 승격하는 기준
    - 프로세스를 하위 큐로 강등하는 기준
    - 프로세스가 도착했을 때, 들어갈 큐를 결정하는 기준
        - 보통 처음 들어오는 프로세스는 우선순위가 가장 높은 큐에 CPU 할당 시간을 짧게하여 배치한다.
        - 만약 주어진 할당 시간 안에 작업을 완료하지 못하면 CPU 할당 시간을 조금 더 주되, 우선순위가 한단계 낮은 큐로 강등한다.
        - 이 과정을 반복하다가 최하위 큐에 배치된다.

