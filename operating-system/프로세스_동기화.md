# 프로세스 동기화

<mark>**프로세스끼리 통신을 하는 경우 누가 먼저 작업할지, 작업이 언제 끝날지 등을 서로 알려주어야 하는데 이를 동기화라고 함**</mark>

</br>

## 1️⃣ 프로세스 간 통신의 종류

프로세스 간 통신(IPC)에는 같은 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함한다.

- 운영체제 도움 없이 통신하는 방식 : 전역 변수, 파일
- 운영체제가 제공하는 통신 방식 : 파이프, 소켓, 원격 프로시저 호출(RPC)


</br>



### 🔷 전역 변수를 이용한 통신
공동으로 관리하는 메모리를 사용하여 데이터를 주고받는 것이다. 

<p align="center">
<img src="https://github.com/user-attachments/assets/7ce36343-5fc4-4b0a-92bd-4751cf066f9c" width="50%" height="50%">
</p>

</br>

데이터를 보내는 쪽에서는 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서는 전역 변수의 값을 읽는다.
이 통신 방식은 동기화에 문제가 있다. 자식 프로세스는 부모 프로세스가 전역 변수에 언제 데이터를 쓸지 모르기 때문에 바쁜 대기를 돌면서 계속 주시해야 한다.


</br>

### 🔷 파일을 이용한 통신

파일 입출력 코드는 크게 3 부분으로 구성

</br>

- 파일을 열고 (open)
- 쓰기 또는 읽기 (write, read)
- 닫늗다. (close)

</br>

<p align="center">
<img src="https://github.com/user-attachments/assets/b8f373b9-1a7d-464a-8417-37ff4574e166" width="50%" height="50%">
</p></br>


파일 입출력 코드를 프로세스 입장에서 보면 프로세스가 입출력 관리 프로세스에 쓰기를 요구하면 데이터가 저장되고, 읽기를 요구하면 입출력 관리 프로세스로부터 데이터를 가져온다. 운영체제 입장에서 보면 저장장치의 데이터를 읽고 쓰는 것도 일반 프로세스와 입출력 프로세스 간의 통신이다.

</br>

파일을 이용한 통신은 부모-자식 관계 프로세스 간 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않는다. 그래서 프로세스가 알아서 동기화를 해야하므로 부모 프로세스가 wait() 함수를 통해 자식 프로세스 작업이 끝날 때까지 기다렸다가 작업을 시작한다. 


</br>

### 🔷 파이프를 이용한 통신

파일 입출력과 같이 open() 함수로 기술자를 얻고 close()함수로 마무리한다. 파이프를 이용한 통신은 전역 변수를 이용한 통신과 마찬가지로 단방향 통신이다. 파이프로 양방향 통신을 하려면 파이프 2개를 사용해야 한다. 

</br>

<p align="center">
<img src="https://github.com/user-attachments/assets/0b92f2f5-2870-4693-b0fa-8721d4d0047f" width="50%" height="50%">
</p></br>

- 이름 없는 파이프 : 일반적으로 부르는 파이프, 부모와 자식 프로세스 간 통신에 사용
- 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하여 서로 관련 없는 프로세스 간 통신에 사용


</br>

### 🔷 소켓을 이용한 통신

일반적으로 원격 프로시저 호출(다른 컴퓨터에 있는 함수를 호출)할 때 소켓을 사용한여 구현한다. 소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다. 소캣은 하나만 사용해도 양방향 통신이 가능하다.

</br>


<p align="center">
<img src="https://github.com/user-attachments/assets/64eaf03c-2458-4bf6-a9b2-57f78ca56f54" width="50%" height="50%">
</p></br>


## 2️⃣ 공유 자원과 임계구역

### 🌕 공유 자원

<mark>**여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말함**</mark>

공유 자원은 여러 프로세스들이 사용하기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다. 만약 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 "경쟁 조건이 발생했다."라고 한다. 이때 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있다. 

</br>

### 🌕 임계 구역

<mark>**공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역**</mark>

임계 구역에서는 프로세스들이 동시에 작업하면 안 된다. 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역 밖에서 기다려야 하며 임계구역의 프로세스가 나와야 들어갈 수 있다. 

</br>

### 🌕 임계구역 해결 조건

1. 상호 배제(mutual exclusion) : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다.
2. 한정 대기(bounded waiting) : 어떤 프로세스도 무한 대기하지 않아야 한다.
3. 진행의 융통성(progress flexibility) : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 것을 의미 

</br>


## 3️⃣ 임계구역 해결 방법

임계구역의 문제를 해결할 수 있는 기본적인 방법은 lock이다. lock을 통해 어떤 프로세스가 임계 구역을 사용하고 있는 중에는 다른 프로세스는 사용하지 못하도록 한다.

```c

extern boolean lock = false;
extern int cSection;

main(){

   while(lock ==true);
   lock = true;
   cSection = cSection + 10; /* 임계구역 */
   lock= false;
}

```

### 🌕 세마포어 (Semaphore)

임계구역 해결 알고리즘 중 하나이다. 

1. 세마포어는 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어간다.
2. 이후 도착한 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다.
3. 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호 조냄

</br>

세마포어는 기존의 알고리즘과 달리 임계구역이 잠겼는지 직접 점검하거나, 바쁜 대기를 하거나, 다른 프로세스에 동기화 메세지를 보낼 필요가 없다. 

```c
Semaphore(n) // RS = n;

P(); // if RS>0 then RS=RS-1; else block(): //until RS>0

/*임계 구역*/

V(); // RS = RS +1; wake_up();

```

- Semaphore(n) : 전역 변수 RS를 n으로 초기화, RS는 현재 사용 가능한 자원의 수가 저장된다.
- P() : 잠긍을 수행하는 코드, RS > 0 면 1만큼 감소시키고 임계구역에 진입, 만약 RS가 0보다 작으면 0보다 커질 때까지 기다린다.
- V() : 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1증가 시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up 신호를 보냄

</br>

아래는 그림으로 보는 예시이다.

<p align="center">
<img src="https://github.com/user-attachments/assets/8e8fb587-3a95-4f31-9ed8-5aea9d2487da" width="70%" height="70%">
</p></br>

</br>

주의해야 할 것은 P() V() 내부 코드가 실행되는 도중에 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못한다. 그러므로 P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되어야 한다.

