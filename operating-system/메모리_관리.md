# 메모리 관리

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다. 따라서 메모리에는 user process뿐만 아니라 os process도 공존한다. 이 과정을 부팅(booting)이라고 한다. 이러한 부팅이 끝나면 실제 여러 application이 메모리에서 작업을 할 수 있다.

</br>

<mark>**메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 관한 문제**</mark></br> 
이런 복잡한 메모리 관리는 Memory Management System(MMS)에서 담당한다.

```
메모리 관리 이중성 : 프로세스 입장에서 작업의 편리함과 관리자 압장에서 관리의 편리함이 충돌을 일으키는 것
현재는 이런 두 입장을 이해관계를 메모리 관리자의 작업이 더욱 복잡해지며 완벽하게 처리하고 있다.  
```

</br>


## 1️⃣ 메모리 관리자 (Memory Management System)
<mark>메모리 관리를 담당하는 하드웨어, 정확히는 Memory Manage Unit이라고 한다.</mark></br>

이 메모리 관리자의 작업은 fetch(가져오기), placement(배치), replacement(재배치)이다.

- <mark>**fetch**</mark> : 프로세스와 데이터를 메모리로 가져오는 작업
  - 보통 프로세스가 요청할 때 가져오지만 필요하다고 예상되는 데이터를 가져오는 방법도 존재(prefetch)
- <mark>**placement**</mark> : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업
  - <code>**Paging**</code>(메모리를 같은 크기로 자르는 것)과 <code>**Segmentation**</code>(프로세스를 크기에 맞게 자르는 것)의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만든다. 
- <mark>**replacement**</mark> : 꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업
  - 교체 알고리즘을 통해서 앞으로 사용하지 않은 프로세스를 내보낸다. 


## 2️⃣ 절대 주소와 상대 주소

- <mark>**절대 주소**</mark> : 실제 물리 주소를 가리키며 메모리 관리자 입장에서 바라본 주소
- <mark>**상대 주소**</mark> : 사용지 영역이 시작되는 주소를 0번지로 변경하여 사용하는 주소

<p align="center">
<img alt="address" src="https://github.com/user-attachments/assets/8edfb6af-dc25-4142-8d86-cbf5eb2a6e28" width="70%" height="70%">
</p></br>

### ▶︎ 상대 주소를 절대 주소로 변환하는 과정

만약 상대 주소를 사용하면 상대 주소를 실제 메모리 내의 물리 주소, 즉 절대 주소로 변환해야 한다. 변환 과정은 아래와 같다. 

<p align="center">
<img alt="address" src="https://github.com/user-attachments/assets/a4a06ac4-e582-4b28-8ec7-adc463b046a9" width="70%" height="70%">
</p></br>


1. 사용자 프로세스가 상대 주소 40번지에 있는 데이터를 요청
2. CPU는 메모리 관리자에게 40번지 있는 내용을 가져오라고 명령
3. 메모리 관리자는 재배치 레지스터를 사용하여 상대 주소 40번지를 절대 주소 400번지를 변환하고 메모리 400번지에 저장된 데이터를 가져온다.

```
재배치 레지스터 : 주소 변환의 기본이 되는 주소 값을 가진 레지스터 (메모리에서 사용자 영역의 시작 주소값 저장)
```

</br>

## 3️⃣ 단일 프로그래밍 환경에서의 메모리 할당

### ▶︎ 메모리 오버레이
<mark>**메모리 크기보다 큰 프로그램을 실행시킬 때, 프로그램을 적당한 크기로 잘라서 가져오는 기법**</mark>


<p align="center">
<img alt="address" src="https://github.com/user-attachments/assets/a112dc75-4dd1-4030-a0da-c4c6b0640033" width="70%" height="70%">
</p></br>

프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다. 메모리 오버레이에서 어떤 모듈을 가져오거나 내볼낼지는 CPU 레지스터 중 하니인 프로그램 카운터(PC)가 결정한다. 

정리하면 메모리 오버레이 다음과 같은 의미를 갖는다.

- 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능하다.
- 프로그램 전체가 아닌 일부만 메모리에 올라와도 실행이 가능하다.  

</br>


### ▶︎ 스왑(swap)
<mark>**메모리가 모자라서 쫗겨난 프로세스를 저장장치의 특별한 공간, 즉 swap area에 모아두는 기법**</mark>

<p align="center">
<img src="https://github.com/user-attachments/assets/4b952a88-75f3-4d00-9186-ec737542fc91" width="70%" height="70%">
</p></br>



- swap area에서 메모리로 데이터를 가져오는 작업은 swap in,
- 메모리에서 swap 영역으로 데이터를 내보내는 작업은 swap out
- swap area는 메모리 관리자가 관리한다.

```
사용자가 인식하는 메모리 크기 4GB = swap area 1GB + 실제 메모리 3GB
```


## 4️⃣ 다중 프로그래밍 환경에서의 메모리 할당

### ▶︎ 메모리 분할 방식

<p align="center">
<img src="https://github.com/user-attachments/assets/52826890-7522-4fa8-a14e-d8ba990a9de5" width="70%" height="70%">
</p></br>

- <mark>가변 분할 방식</mark> : 프로세스의 크기에 따라 메모리를 나누는 것 (연속 메모리 할당)
- <mark>고정 분할 방식</mark> : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것 (비연속 메모리 할당)

가변 분할 방식은 배치에 제약이 없기에 프로세스를 연속된 공간에 배치할 수 있지만 메모리 관리가 어렵고 고정 분할 방식은 배치에 제약이 있어 메모리 공간이 낭비될 수 있지만 메모리 관리가 용이하다.

### ▶︎ 단편화

- <mark>외부 단편화</mark> : 할당한 프로세스의 크기보다 메모리에 남아 있는 조각이 작아서 할당이 불가능한 현상 (가변 분할 방식에서 발생)
  - 이를 해결하기 위해 메모리 배치 방식이나 조각 모음을 사용한다.   
- <mark>내부 단편화</mark> : 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상 (고정 분할 방식에서 발생)


</br>

```
메모리 배치 방식
- 최초 배치 : 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스 배치 (단편화를 고려하지 않음)
- 최적 배치 : 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스 배치
- 최악 배치 : 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스 배치 (빈 공간의 크기가 클 때 효과적)

조각 모음
- 단편화가 발생하면 이미 배치된 프로새스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만드는 것 
```


</br>
