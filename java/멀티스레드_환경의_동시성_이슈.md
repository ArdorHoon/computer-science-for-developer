# 멀티스레드 환경의 동시성 이슈 및 해결 방법


멀티스레드 환경은 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것을 말한다. (자세한 내용 [프로세스와 스레드](https://github.com/ArdorHoon/computer-science-for-developer/blob/main/operating-system/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C.md) 참조)

</br>

java에서 이런 멀티스레드 환경을 구축할 때 동시성이라는 이슈가 생길 수 있다는데 동시성은 무엇일까?

</br>

## 동시성 이슈
멀티스레드 환경에서 Thread들은 서로 자원을 공유하고 번갈아 가면 작업을 처리한다. 하지만 이 때 자원을 공유하고 있다는 이유 때문에 여러 Thread가 해당 자원을 두고 동시에 점유(race condition)하려고 하면 문제가 생길 수 있다. <mark>**즉, 여러 스레드가 동시에 공유 자원에 접근하여 발생하는 문제**</mark>

</br>

이 문제가 바로 <mark>**동시성(concurrency) 이슈**</mark>이다. 만약 이러한 동시성 이슈가 없이 Thread들이 정상 동작한다면 우리는 <code>**Thread safe**</code>하다고 말할 수 있다.


</br>

## 동시성 문제 해결 방법

### 1️⃣ Synchronized (암시적 Lock) 

<mark>문제가 되는 메서드나 변수에 <code>synchronized</code>를 이용해 Lock을 거는 방식이다.</mark> 즉, 여러 스레드가 동시에 공유 자원에 접근을 못하게 하여 한 번에 하나의 스레드만 해당 자원에 접근할 수 있게 해주는 것</br>

하지만 이를 사용하면 한 번에 하나의 스레드만 접근이 가능하기 때문에 병렬성이 매우 낮아질 수 있다. 

</br>

아래의 경우, 메서드에 <code>synchronized</code> 사용해서 해당 count라는 자원에 순차적으로 접근하여 로직을 처리할 수 있다.

```java

    @Test
    void testThread() throws Exception{

        int maxCnt = 1000;

        for (int i = 0; i < maxCnt; i++) {
            new Thread(() -> {
                increaseCount();
            }).start();
        }

        Thread.sleep(1000);

        Assertions.assertThat(count).isEqualTo(maxCnt);

    }

    public synchronized void increaseCount(){
        count++;
        System.out.println(count);
        
    }


```

</br>


![lock](https://github.com/user-attachments/assets/8b1c2bfb-82b2-4980-9bf9-e8fbe60f4920)


</br>


### 2️⃣ ReentrantLock (명시적 Lock) 

<mark>**해당 Lock의 범위를 메서드나 내부에서 한정하기 어렵거나, 동시에 여러 Lock을 사용하고 싶을 때 사용**</mark>한다. 직접적으로 Lock 객체를 생성하여 사용할 수 있다. 

```java

  @Test
    void testThread() throws Exception{
        Count count = new Count();

        int maxCnt = 100;

        for (int i = 0; i < maxCnt; i++) {
            new Thread(() -> {
                //count object lock
                count.getLock().lock();

                //로직 처리
                System.out.println(count.increaseCount());

                //count object unlock
                count.getLock().unlock();


            }).start();
        }

        Thread.sleep(100);

        Assertions.assertThat(count.getCount()).isEqualTo(maxCnt);

    }

    class Count{

        private int count =0;
        private Lock lock = new ReentrantLock();

        public int getCount(){
            return count;
        }

        public int increaseCount(){
            return count++;
        }

        public Lock getLock(){
            return lock;
        }
    }

```

</br>

### 3️⃣ Volatile

</br>


### 4️⃣ Atomic 

</br>
