# 리플렉션(Reflection) 
<mark>**런터암 시점에서 클래스나 객체의 속성이나 메소드를 동적으로 접근할 수 있는 기능**</mark>

이 기능 덕분에, 개발자는 코드의 유연성과 확장성을 높일 수 있다. <code>java.lang.reflect</code>를 통해 리플랙션을 사용할 수 있다. 

아래는 리플렉션의 대표적인 예제이다.

```java
    Class clazz = Class.forName("java.lang.String");
    Method[] methods = clazz.getDeclaredMethods();
    for(Method method:methods){
            System.out.println(method.getName());
    }
```
- Class.forName("java.lang.String")은 String 클래스에 대한 Class 객체를 가지고 온다.
- getDeclaredMethods()를 사용해서 가져온 클래스에 정의된 메소드 정보를 얻어냄


</br>

## Class
자바에서 클래스 정보를 접근하기 위해 크게 3가지 문법을 사용할 수 있다.
```java
        // getClass() 메소드 사용
        String str = "Hello";
        Class clazz1 = str.getClass();

        // .class 문법 사용
        Class clazz2 = String.class;

        //Class.forName() 사용
        Class<?> clazz3 = Class.forName("java.lang.String");

```

</br>

아래와 같이 class에 접근하여 method와 field 정보에 접근할 수 있다. 
```java
        Class<?> clazz = String.class;

        System.out.println("Class name : " + clazz.getName());

        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println("Method name: " + method.getName());
        }

        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            System.out.println("Field name: " + field.getName());
        }
        
        /* 결과

        Class name : java.lang.String
        Method name: value
        Method name: equals
        Method name: length
        .
        .
       Field name: value
       Field name: coder
       Field name: hash
        */

```

</br>

## Constructor
리플렉션을 사용하여 클래스의 생성자 접근하여 객체 동적 생성

- <code>getConstructor()</code>: public 생성자에 접근할 때 사용
- <code>getDeclaredConstructor()</code>: 클래스에 선언된 모든 생성자에 접근할 때 사용

```java
class Sample{
    public Sample(){

    }

    private Sample(String msg){

    }

}

public class Main {
    public static void main(String[] args) throws Exception {

        Class<?> clazz = Sample.class;

        Constructor<?> publicConstructor = clazz.getConstructor();
        Constructor<?> privateConstructor = clazz.getDeclaredConstructor(String.class);

        // private constructor can be access
        privateConstructor.setAccessible(true);



    }

}

```

</br>

Constructor 객체의 newInstance()를 통해서 객체를 생성 
```java
        Sample s1 = (Sample) publicConstructor.newInstance();
        Sample s2 = (Sample) privateConstructor.newInstance("arg");
```

</br>

## Field
리플렉션을 사용하면 클래스의 필드(멤버 변수)에 프로그래밍적으로 접근하고 조작하는 방법 
- <code>getField()</code>: public 필드에 접근할 때 사용
- <code>getDeclaredField()</code>: 클래스에 선언된 모든 필드에 접근할 때 사용

```java
class Sample{
    public int name;
    private String pn;

}

public class Main {
    public static void main(String[] args) throws Exception {

        Class<?> clazz = Sample.class;

        Field publicField = clazz.getField("name");
        Field privateField = clazz.getDeclaredField("pn");
        
        // private field can be access
        privateField.setAccessible(true);

    }

}

```

</br>

그리고 아래와 같이 필드에 접근하여 수정할 수 있다.

```java
        Sample sample = new Sample();

        // read public field
        int publicFieldValue = (Integer) publicField.get(sample);
        System.out.println("Public Field value: " + publicFieldValue);

        // read private field
        String privateFieldValue = (String) privateField.get(sample);
        System.out.println("Private Field Value: " + privateFieldValue);

        // correct field value
        publicField.set(sample, 10);
        privateField.set(sample, "Hello World");

```

</br>

## Method



</br>
