# 객체지향 설계 원칙

<mark>SOLID라는 좋은 객체지향의 설계의 5가지 원칙이 존재한다.</mark></br>
SOLID 원칙을 지키면 변경에 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다.


</br>

## SRP(단일 책임 원칙)

<mark>**작성된 클래스는 하나의 기능(책임)만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어 있어야 한다는 원칙**</mark></br>

결국 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 함을 의미한다. 이 SRP 원칙을 통해서 다른 원칙들의 기초가 되고 코드의 가독성 향상과 유지보수가 용이하게 된다.


아래의 예시는 SRP를 위반한 코드이다. Car 클래스에서 각 차의 정보를 보여주는 getInfo를 호출하고 있다. 이 getInfo는 BMW나 KIA냐에 따라 정보를 출력하는데 이렇게 되면 자동차 모델이 계속적으로 추가되었을 때 Car 클래스의 코드 가독성뿐만 아니라 유지보수하기가 힘들어진다.

```java

// Car 클래스
public class Car {

    private String car;

    public void setCar(String car) {
        this.car = car;
    }

    public void getInfo () {

        if(animal == "KIA") { // KIA
            System.out.println("KIA Info ...");
        }
        else if(animal == "BMW") { // BMW
            System.out.println("BMW Info..");
        }
    }

}

```

</br>

그렇다면 이를 해결하기 위해 우리는 Car를 추상 클래스로 만들고 각 자동차 모델을 이를 상속받아 구현하게 해서 한 클래스가 하나의 책임만을 가지게 해줘야 한다.

```java

// Car 클래스
abstract class Car {
  abstract void getInfo();
}

//KIA 클래스
class KIA extends Car {
    @Override
    void getInfo() {
        System.out.println("KIA Info ...");
    }
}

//BMW 클래스
class BMW extends Car {
    @Override
    void getInfo() {
        System.out.println("BMW Info..");
    }
}
```

</br>


## OCP(개방-폐쇄 원칙)
<mark>**기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야 하는 원칙**</mark></br>

보통 OCP를 확장(기능 추가)에 대해서는 개방적(open)이고, 수정에 대해서는 폐쇄적(closed)이어야 한다는 의미로 정의한다.

</br>

- 확장에 open : 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가할 수 있다.
- 변경에 close : 객체를 직접적으로 수정하는건 제한해야 한다.

</br>


OCP에 위배된 코드

```java

// Car 클래스
class Car {
	String model;
    
    Car(String type) {
    	this.model = model;
    }
}

// Car 모델을 받아서 튜닝 해주는 클래스 모듈
class TuningCar{
     void tuning(Car car) {
        if(animal.type.equals("BMW")) {
            System.out.println("tuning BMW");
        } else if(animal.type.equals("KIA")) {
            System.out.println("tuning KIA");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        TuningCar tuning = new TuningCar();
        
        Car kia = new Car("KIA");
        Car bmw = new Car("BMW");

        tuning.tuning(kia); // tuning KIA
        tuning.tuning(bmw); // tuning BMW
    }
}

```

위에 코드에서 만약 모델이 추가되려면 TuningCar 클래스를 직접 수정해주어야 한다. 한 두개 추가는 상관없지만 수 백개가 추가된다고 하면 굉장히 클래스가 무거워지고 다루기도 힘들 것이다. 그래서 아래와 같이 추상화 작업(interface or abstract class)을 통해서 추상화에 의존하도록 변경해주어야 한다. 


```java

// Car 클래스
abstract class Car {
  abstract void tuning();
}

class TuningCar {
   void tuning(Car car) {
        car.tuning();
    }
}

class KIA extends Car {
    @Override
    void tuning() {
        System.out.println("KIA tuning ...");
    }
}


class BMW extends Car {
    @Override
    void tuning() {
        System.out.println("BMW tuning..");
    }
}

}


public class Main {
    public static void main(String[] args) {
        TuningCar tuningCar = new TuningCar();

        Car bmw = new BMW();
        Car kia = new KIA();

        tuningCar.tuning(bmw); //tuning BMW
        tuningCar.tuning(kia); //tuning KIA
    }
}

```




</br>






## LSP(리스코프 치환 원칙)

content

## ISP(인터페이스 분리 원칙)

content

##  DIP(의존 역전 원칙)

content

