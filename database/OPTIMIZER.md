# Database Optimizer

<mark>**SQL문을 실행하는 가장 효율적인 방법을 결정하는DBMS의 핵심 엔진**</mark></br>

이를 통해 옵티마이저는 2가지 역할을 수행한다. 
- 쿼리 실행 성능을 최적화하여 더 빠르고 효율적인 데이터 처리
- 쿼리 실행의 자원 소비를 줄여 시스템 성능을 개선


</br>


## 1️⃣ Optimizer 동작 방식


<p align="center">
<img src="https://github.com/user-attachments/assets/ab5936ee-8b61-4849-bb36-e5f0df39ecd0" width="70%" height="70%"></br>
</p></br>



1. <mark>**쿼리 파싱 (Query Parsing)** </mark> : SQL 쿼리는 구문 분석을 거쳐 **추상 구문 트리**로 변환함
2. <mark>**논리적 최적화 (Logincal Optimization)** </mark> : 파싱된 쿼리는 논리적 최적화를 거친다. (불필요한 조건 제거, 조인 순서 변경, 조건 통합)
3. <mark>**통계 정보 및 메타데이터 활용(Statistics and Metadata Utilization)** </mark> : 옵티마이저는 **테이블 통계, 인덱스 정보, 데이터 분포** 등을 기반으로 쿼리를 최적화
4. <mark>**물리적 최적화 (Physical Optimization)** </mark> : 논리적 최적화가 끝난 후, 옵티마이저는 쿼리 실행을 위해 물리적 실행 계획을 선택 (인덱스 선택, 조인 방법 결정 등)
5. <mark>**실행 계획 생성(Execution Plan Generation** </mark>) : 물리적 최적화가 끝나면, 최종적으로 실행 계획 생성
6. <mark>**쿼리 실행 (Query Execution)** </mark> : 최종적으로 선택된 실행 계획 기반으로,  DB는 실제로 데이터를 처리하고 결과를 반환 


</br>


<code>**그림 Reference**</code>
- Row-Source Generator : 옵티마이저가 생성한 계획을 SQL Engine이 실행 가능한 코드로 포맷
- Parser : SQL문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱해서 파싱 트리 생성
- Optimizer
  1. Query Transformer : 파싱된 SQL을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL로 변환이 가능한지를 판단한여 번환 작업 수행
  2. Estimator : 시스템 통계정보를 dictionary로부터 수집하여 SQL을 실행할 때 소요되는 총비용 계산
  3. Plan Generator : Estimator를 통해 계산된 값들을 토대로 후보군이 되는 실행계획을 도출


</br>

## 2️⃣ Optimizer 종류

### ⭕ 규칙 기반 옵티마이저(RBO : Rule-Based Optimizer)
미리 정의된 규칙을 사용하여 실행 계획을 선택하는 오래된 방식입니다. 이러한 규칙은 특정 종류의 쿼리나 연산을 우선시하는 경향이 있습니다.



</br>


### ⭕ 비용 기반 옵티마이저(CBO : Cost-Based Optimizer)
최신 데이터베이스에서 가장 일반적인 방식으로, 다양한 실행 계획의 비용을 계산하고 가장 적은 비용을 가진 계획을 선택합니다. CBO는 RBO보다 더 유동적이고, 데이터베이스의 성능에 더 최적화된 방식입니다.



</br>


### ⭕ 표로 보는 RBO vs CBO

|제목 셀1|제목 셀2|
|---|---|
|내용 1|내용 2|
|내용 5|내용 6|
|내용 9|내용 10|

</br>



## 3️⃣ 옵티마이저의 한계

옵티마이저는 모든 상황에서 완벽하게 최적화를 보장할 수 없다. 주요 한계는 아래와 같다.

1. <mark>**통계의 정확성에 의존**</mark> : 옵티마이저는 테이블 통계와 데이터 분포를 바탕으로 실행 계획을 선택한다. 그러나 통계가 부정확하거나 오래된 경우, 옵티마이저는 잘못된 실행 계획을 선택할 수 있다.
2. <mark>**복잡한 쿼리에서의 한계**</mark> : 옵티마이저는 쿼리의 복잡성에 따라 성능을 최적화할 수 있는 능력이 제한될 수 있다.
3. <mark>**인덱스 사용에 대한 한계**</mark> : 옵티마이저는 인덱스를 활용하여 쿼리 성능을 개선할 수 있지만, 인덱스 존재 여부와 적합성을 제대로 파악하지 못하는 경우가 있을 수 있다.
4. <mark>**비용 모델의 한계**</mark> : 대부분의 옵티마이저는 CBO를 사용하여 실행 계획을 선택하는대 비용 모델이 실제 시스템 환경과 완전히 일치하지 않을 수 있기 때문에, 옵티마이저가 예측한 비용가 실제 실행 비용 간에 차이가 발생할 수 있다.
5. <mark>**복잡한 데이터 분포 처리의 어려움**</mark> : 옵티마이저는 데이터 분포에 대한 통계를 바탕으로 최적화 결정을 내리는데, 데이터가 매우 비정형적이거나 분포가 고르지 않은 경우, 옵티마이저가 잘못된 실행 계획을 선택할 수 있다.

</br>
