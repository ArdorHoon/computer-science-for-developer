# DB 인덱스 설계와 최적화


## 1️⃣ 인덱스(index)
<mark>**인덱스는 데이터베이스에서 데이터를 빠르게 검색하고 조회하기 위한 자료 구조**</mark></br>

인덱스는 **특정 칼럼 또는 칼럼의 조합에 대한 값과 해당 값이 존재하는 테이블 내의 물리적인 위치를 매핑**한다. 이를 통해 데이터베이스는 인덱스를 사용하여 효율적으로 데이터를 검색하고 필요한 정보를 빠르게 가져올 수 있다. 대략 테이블 크기의 10% 공간이 추가로 필요하다. (인덱스 페이지)

인덱스는 ${{\color{#DD6565}주로\ 테이블의\ 기본 키(primary key),\ 외래 키(foreign key),\ 그리고\ 자주\ 검색되는\ 컬럼에\ 생성}}$된다.
</br>

그러나 인덱스는 데이터 검색 속도를 향상시키는 반면, 데이터 삽입, 수정, 삭제 작업의 성능을 저하시킬 수 있으므로 적절한 인덱스 설계가 필요하다.

</br>


## 2️⃣ 인덱스 종류

### ✴︎ Clusted Index(클러스터형 인덱스)
- 테이블당 1개만 존재
- 키본키로 지정하면 자동으로 클러스터형 인덱스가 생성
- 실제 저장된 데이터와 **같은 무리의 페이지 구조** 가짐
- 클러스트형 인덱스를 기준으로 데이터가 자동 정렬됨 

</br>

### ✴︎ Non-Clustered Index(비클러스터형 인덱스)
- 한 테이블에 여러개 설정 가능
- UNIQUE 키워드로 고유 컬럼 지정 시, 자동으로 보조 인덱스가 생성
- 실제 저장된 데이터와 **다른 무리의 별도 페이지 구조** 가짐
- 클러스터형 인덱스와 달리 데이터 정렬하지 않음
- <code>CREATE INDEX</code> 문으로 직접 비클러스터형 인덱스 생성 가능 

</br>

## 3️ 인덱스 설계 시 고려해야할 사항


### ✅ 인덱스로 고려할만한 설계

1. **WHERE 절에 사용되는 열** : 자주 사용되야 인덱스로서 가치가 있음
2. **SELECT 절에 자주 등장하는 컬럼**
3. **JOIN 절에 자주 사용되는 열**
4. **ORDER BY 절에 사용되는 열** : 데이터 페이지가 자동 정렬되기 때문에 클러스터형 인덱스 유리

</br>


### ✅ 인덱스로 만들면 안되는 설계
1. **대용량 데이터가 자주 입력되는 경우**
   - 클러스터형 인덱스의 경우, 빈번한 페이징으로 부하가 생겨남 (이 때는 UNIQUE만 설정하는게 좋음)
3. **데이터 중복도가 높은 열**
4. **자주 사용되지 않는 열**

</br>


### ⛔ 추가 주의 사항
- 데이터 변경이 얼마나 자주 일어나는지 고려해야 함
- 단일 테이블에 인덱스가 많으면 속도 저하
- 검색할 데이터가 전체 데이터의 일정 부분 이상이면 인덱스 사용 시, 작업량이 많아짐
- 사용하지 않는 인덱스는 제거
- 테이블에 클러스터형 인덱스가 아예 없는 것이 좋은 경우도 있음

</br>


## 3️ 인덱스 최적화 전략

1. <mark>**적절한 컬럼 선택하여 인덱스 생성**</mark>: 자주 검색되는 컬럼, 조인에 사용되는 컬럼, 데이터의 분포가 균일한 컬럼에 생성하는 것이 좋음
2. <mark>**인덱스의 크기와 수를 최적화**</mark> : 인덱스가 너무 많으면 데이터베이스의 유지 관리 비용 증가하고 성능 저하를 일으킬 수 있음, 정기적은 인덱스 리뷰와 유지 관리를 통해 데이터베이스 성능을 지속적으로 모니터링
3. <mark>**중복 인덱스 피하기**</mark> : 같은 필드나 필드의 조합에 대해 중복해서 생성되는 인덱스는 저장 공간을 낭비하고 업데이트 성능을 저하시킴

</br>
